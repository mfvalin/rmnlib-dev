! * RMNLIB - Library of routines for C and FORTRAN programming
! * Copyright (C) 2020  Division de Recherche en Prevision Numerique
! *                     Environnement Canada
! *
! * This library is free software; you can redistribute it and/or
! * modify it under the terms of the GNU Lesser General Public
! * License as published by the Free Software Foundation,
! * version 2.1 of the License.
! *
! * This library is distributed in the hope that it will be useful,
! * but WITHOUT ANY WARRANTY; without even the implied warranty of
! * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! * Lesser General Public License for more details.
! *
! * You should have received a copy of the GNU Lesser General Public
! * License along with this library; if not, write to the
! * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! * Boston, MA 02111-1307, USA.
!
! extra definitions of types and macros to interface with C code
! and libc
!
! the following block is normally produced by running c_binding_extras.c
! in case file c_binding_extras.hf is not present, use these values
#if defined(NO_C_BINDING_EXTRAS)
  integer, parameter :: C_SSIZE_T = 8
  integer, parameter :: C_TIME_T  = 8
  integer, parameter :: C_SUSECONDS_T = 8
  integer, parameter :: C_CLOCK_T = 8
  integer, parameter :: C_CLOCKS_PER_SEC = 1000000
  integer, parameter :: C_MODE_T  = 4
  integer, parameter :: O_APPEND  = 1024
  integer, parameter :: O_CREAT   = 64
  integer, parameter :: O_EXCL    = 128
  integer, parameter :: O_TRUNC   = 512
  integer, parameter :: O_RDWR    = 2
  integer, parameter :: O_RDONLY  = 0
  integer, parameter :: O_WRONLY  = 1
#else
#include <c_binding_extras.hf>
#endif

! C_LoC transforms any address into a type(C_PTR) object
#if ! defined(C_LoC)
#define C_LoC(what) transfer(loc(what),C_NULL_PTR)
#endif

! Cstr transforms a Fortran string into a C NULL terminated string
#if ! defined(Cstr)
#define Cstr(fstr) (trim(fstr)//ACHAR(0))
#endif

! permission bits for files and directories
  integer, parameter :: S_IRWXU = O'700'
  integer, parameter :: S_IRUSR = O'400'
  integer, parameter :: S_IWUSR = O'200'
  integer, parameter :: S_IXUSR = O'100'
  integer, parameter :: S_IRWXG = O'070'
  integer, parameter :: S_IRGRP = O'040'
  integer, parameter :: S_IWGRP = O'020'
  integer, parameter :: S_IXGRP = O'010'
  integer, parameter :: S_IRWXO = O'007'
  integer, parameter :: S_IROTH = O'004'
  integer, parameter :: S_IWOTH = O'002'
  integer, parameter :: S_IXOTH = O'001'  

type, BIND(C) :: C_FILEPTR
  type(C_PTR) :: p
end type

type, bind(C) :: timeval
  integer(C_TIME_T) :: tv_sec
  integer(C_SUSECONDS_T) :: tv_usec
end type

type, bind(C) :: timezone
  integer(C_INT) :: tz_minuteswest
  integer(C_INT) :: tz_dsttime
end type

! interfaces tp popular libc functions
interface
  ! tz will often be C_NULL_PTR
  function c_gettimeofday(tv, tz) result(ok) BIND(C,name='gettimeofday')
    import :: C_PTR, timeval, C_INT
    type(timeval), intent(OUT) :: tv
    type(C_PTR), intent(IN), value :: tz
    integer(C_INT) :: ok
  end function c_gettimeofday
  function c_clock() result(time) bind(C,name='clock')
    import :: C_CLOCK_T
    integer(C_CLOCK_T) :: time
  end function c_clock

  function c_gethostid() result(h) bind(C,name='gethostid')
    import :: C_LONG
    integer(C_LONG) :: h
  end function c_gethostid

  function c_numa_node_of_cpu(cpu) result(n) bind(C,name='numa_node_of_cpu')
    import :: C_INT
    integer(C_INT), intent(IN), value :: cpu
    integer(C_INT) :: n
  end function c_numa_node_of_cpu
  function c_sched_getcpu() result(c) bind(C,name='sched_getcpu')
    import :: C_INT
    integer(C_INT) :: c
  end function c_sched_getcpu

  function c_alarm(seconds) result(seconds_since) BIND(C,name='alarm')
    import :: C_INT
    integer(C_INT), intent(IN), value :: seconds
    integer(C_INT) :: seconds_since
  end function c_alarm

  function c_chdir(path) result(ok) BIND(C,name='chdir')
    import :: C_CHAR, C_INT
    character(C_CHAR), dimension(*), intent(IN) :: path
    integer(C_INT) :: ok
  end function c_chdir

  function c_system(cmd) result(ok) BIND(C,name='system')
    import :: C_CHAR, C_INT
    character(C_CHAR), dimension(*), intent(IN) :: cmd
    integer(C_INT) :: ok
  end function c_system

  function c_unlink(path) result(ok) BIND(C,name='unlink')
    import :: C_CHAR, C_INT
    character(C_CHAR), dimension(*), intent(IN) :: path
    integer(C_INT) :: ok
  end function c_unlink

  function c_mkdir(path, mode) result(ok) BIND(C,name='mkdir')
    import :: C_CHAR, C_INT, C_MODE_T
    character(C_CHAR), dimension(*), intent(IN) :: path
    integer(C_MODE_T), intent(IN), value :: mode
    integer(C_INT) :: ok
  end function c_mkdir
  function c_rmdir(path) result(ok) BIND(C,name='rmdir')
    import :: C_CHAR, C_INT
    character(C_CHAR), dimension(*), intent(IN) :: path
    integer(C_INT) :: ok
  end function c_rmdir

  function c_open(path, flags, mode) result(fd) bind(C,name='open')
    import :: C_CHAR, C_INT, C_MODE_T
    character(C_CHAR), dimension(*), intent(IN) :: path
    integer(C_INT), intent(IN), value :: flags
    integer(C_MODE_T), intent(IN), value :: mode
    integer(C_INT) :: fd
  end function c_open
  function c_fopen(path, mode) result(file) bind(C,name='fopen')
    import :: C_PTR, C_CHAR, C_FILEPTR
    character(C_CHAR), dimension(*), intent(IN) :: path
    character(C_CHAR), dimension(*), intent(IN) :: mode
    type(C_FILEPTR) :: file
  end function c_fopen

  function c_read(fd, buf, cnt) result(nb) bind(C,name='read')
    import :: C_INT, C_PTR, C_SIZE_T, C_SSIZE_T
    integer(C_INT), intent(IN), value :: fd
    type(C_PTR), intent(IN), value :: buf
    integer(C_SIZE_T), intent(IN), value :: cnt
    integer(C_SSIZE_T) :: nb
  end function c_read
  function c_fread(buf, msize, mnbr, file) result(nitm) bind(C,name='fread')
    import :: C_PTR, C_SIZE_T, C_FILEPTR
    type(C_PTR), intent(IN), value :: buf
    integer(C_SIZE_T), intent(IN), value :: msize, mnbr
    type(C_FILEPTR), intent(IN), value :: file
    integer(C_SIZE_T) :: nitm
  end function c_fread

  function c_write(fd, buf, cnt) result(nb) bind(C,name='write')
    import :: C_INT, C_PTR, C_SIZE_T, C_SSIZE_T
    integer(C_INT), intent(IN), value :: fd
    type(C_PTR), intent(IN), value :: buf
    integer(C_SIZE_T), intent(IN), value :: cnt
    integer(C_SSIZE_T) :: nb
  end function c_write
  function c_fwrite(buf, msize, mnbr, file) result(nitm) bind(C,name='fwrite')
    import :: C_PTR, C_SIZE_T, C_FILEPTR
    type(C_PTR), intent(IN), value :: buf
    integer(C_SIZE_T), intent(IN), value :: msize, mnbr
    type(C_FILEPTR), intent(IN), value :: file
    integer(C_SIZE_T) :: nitm
  end function c_fwrite

  function c_close(fd) result(ok) BIND(C,name='close')
    import :: C_INT
    integer(C_INT), intent(IN), value :: fd
    integer(C_INT) :: ok
  end function c_close
  function c_fclose(file) result(ok) BIND(C,name='fclose')
    import :: C_INT, C_FILEPTR
    type(C_FILEPTR), intent(IN), value :: file
    integer(C_INT) :: ok
  end function c_fclose

end interface
